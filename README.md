# Binout
Matlab functions to work with LS-DYNA `binout` files. The function `get_binout_data()` (called the binout reader) is the one that reads the binout file.
The function `get_d3plot_d3thdt_control_data()` is a helper function that is called (internally) from within the binout reader function.
The function `struct2graph()` is a standalone function that graphically displays content (or fields) of a nested MATALB `struct`. The MATLAB source files of 
the functions are in the [`src`](/src/) folder.

For convenience, sample LS-DYNA files are provided in the [`LS-DYNA-sample`](/LS-DYNA-sample/) folder. You can download these files (note: the `binout` is about 78 MB) and use the MATLAB script `test1.m` in the `src` folder to get started. 

## binout reader
### What it does?
The function `get_binout_data()` takes the path to an LS-DYNA `binout` file and returns the data in it to be 
easily manipulated (i.e. post-processed) in MATLAB. 

### what is `binout`?
Binout is a binary file generated by [LS-DYNA](https://www.ansys.com/products/structures/ansys-ls-dyna) after running an LS-DYNA model, and it contains various result 
databases, such as "matsum" (for material summary, like energy and rigid body velocities data), "nodout" (for nodal data, like displacements and velocities), "elout" (for element data, like stresses, stress-resultants, and strains), and so on. 

### Usage
The formal syntax is 
```
[binin] = get_binout_data(binout_filename)
```
#### inputs:
`binout_filename` =  (absoulte or relative) path to the root binary `binout` file. Type: [`char`|`string`]. 
This input argument is [Required]. If there are more than one binout file, the function is configured to auto-detect and read them sequentially. Data from 
these files will be joined. 

#### outputs:
`binin` = structure containing all the data in the `binout` file(s). Type: MATLAB scalar structure [`struct`]. 

This is a highly nested structure. Use the "." (dot) indexing method in MATLAB to traverse the `binin` structure to arrive at a data of interest. 
The returned `binin` structure will have `n` root fields, where (`n-1`) is the number of databases contained in the `binout` file(s), such as "matsum", "nodout", etc. 
The last n<sup>th</sup> field (when available) is called "control". Every root field is itself a scaler structure. 

Some kinds of root structures will have intermediate sub-structures (as in the `binout` file). At some level, there will be idnentically two structures: 
"metadata" and "data". For example, the "binin.matsum" structure will have the fields "metadata" and "data" as its immediate fields. On the other hand, the 
"binin.elout" structure will contain intermediate fields like "shell". In this case, the "metadata" and "data" structures are fields of "binin.elout.shell".

The "data" structure has fields whose names are borrowed directly from the original `binout` file. The values associated with these fields are the actual 
data of interest. The naming of the fields are practically self-explainatory.

The "metadata" structure is similar to the "data" (described above), and it contains mostly meta-data and few important data, namely the id's of parts, 
nodes, etc. The id's are usually stored in the "ids" field of the "metadata" structure.

The root field "control" under the `binin` structure contains supplementary control data retrieved from the root `d3plot` file, which is provided by 
(internally) calling the `get_d3plot_d3thdt_control_data()` helper function. The binout reader function will auto-detect the root d3plot file. 
Among the control data retrieved is the element-node connectivity arrays and some others like the initial geometry.

#### notes
The values of the fields of the "data" structure are in general 2D arrays except "time" (which is always a column vector). Rows of the 2D arrays correspond to 
time instants (so that the number of rows equal the number of entries of the time vector). The columns of the 2D arrays correspond to the IDs of the entities
(like parts, nodes, etc). The ids of the entities are (generally) stored in the field "ids" in the "metadata" structure. As exceptions, the IDs of elements and
contacts are stored directly in the "data" structure itself. The columns of the 2D arrays in the "data" structures in the "elout" database (say "elout.shell") correspond to elements IDs (stored in "ids") _and_ their 
integration points (the number of which is stored in "nip").

Again, the naming of fields in "data" and "metadata" are explicit and self-explainatory (e.g. "kinetic_energy", "time", "x_velocity", "x_displacement", etc). 
As exceptions, some fields in the "data" structure for the substructures of "elout" may need interpretations as they are abbreviated. The stresses are 
abreviated by "sig_xx", "sig_xy", etc ("sig" for "sigma"). Likewise, strains are indicated by "eps_xx" and so on ("eps" for "epsilon"). The effective plastic strain is 
either denoted by "yield" (for "solid" and "tshell"),"plastic_strain" (for "shell") or "plastic_eps" (for "beam"). Effective von-Mises stress (if available) is denoted by "effsg".
For shells, "upper_" and "lower_" are used as pre-fixes to refer to upper-most layer and lower-most layers. 

Lastly, the structuring and naming of fields are exactly borrowed from the `binout` file. So, if one is already familiar with opening `binout` files in LS-PrePost, 
then there is no need to make further explaination since (in this case) the `binin` structure should be very familiar too. 

#### optional
If needed, one can use the standalone function `struct2graph()` to visually display the hierarchy map of the `binin` structure. The function accepts 
a scalar (possibly highly nested) MATLAB structure as the first input argument, and it produces the figures and returns their handles as output. 
If this is your first time, provide the second input argument (called `labelQ`) with value equals to `"All"` so that every root sub-structure (under the `binin`) 
gets displayed in a seperate figure that shows all the terminal fields under "data" and "metadata". The input `struct` can be nested with arbitrary depth.     

#### final remarks
The aim of the work presented herein is to make working with LS-DYNA results easier for engineers and researchers, so please let us know if you encounter any 
problems or if you need additional clarifications about how to make this work in real use.  


## Motivations
The work is shared for three aims:
+ Help (engineers and researchers) :heart: to easily work with LS-DYNA results.
+ Enrich Matlab by affording a tool to import real-world data from world class FEA solver (LS-DYNA).
+ Extend LS-DYNA by allowing users to make use of the very powerful tools in MATLAB to perform additional post-processing calculations and generate graphics with publication-quality to share with others. 

We hope the work will be useful.

## Contributions
This work is part of a PhD study at the [Blast and Impact Engineering Research Group](https://twitter.com/SheffieldBlast), 
at the [University of Sheffield](https://sheffield.ac.uk) (2023)

supervised by: 
+ Prof. Andrew Tyas (a.tyas@sheffield.ac.uk)
+ Dr. Samuel E. Rigby (sam.rigby@sheffield.ac.uk; [@Dr_SamRigby](https://twitter.com/Dr_SamRigby))
+ Dr. Maurizio Guadagnini (m.gaudagnini@sheffield.ac.uk)

developed by:
+ Dr. Samuel E. Rigby (sam.rigby@sheffield.ac.uk)
+ Saud A. E. Alotaibi (salotaibi2@sheffield.ac.uk; [@saudbinayed](https://twitter.com/saudbinayed)), sponsored by [Qassim University](https://qu.edu.sa), Saudi Arabia, and the Saudi Arabian Cultural Bureau in London, UK.

 `   